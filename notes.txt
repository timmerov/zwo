
- camera and telescope have a field of view of about 20" = 0.3 degrees.
- the width of the image is 1936 pixels which is about 1894" = 31' 34" = 0.298 degrees
- the height of the image is 1072 pixels which is about 1072" = 17' 52" = 0.526 degrees
- stellarium right ascension seems to be off by an hour. daylight savings time?
- the width is about the distance from polaris to the celestial north pole.
- polaris saturates at about 280 ms.
- magnitude 11+ stars show up in 1.0s exposure. quite clear in 2.0s.

- focuser distance setting is about 28mm for stars.
that's the distance between the edge of the camera and the edge of the focuser housing.
it was 29 mm prior to recent calibration.

- the mount will not turn the payload upside down.
if you try to move it too far west it will sew to the far east.

Siril Tutorial: Image Stacking & Processing in Astrophotography
https://sathvikacharyaa.github.io/sirilastro/


collimation procedure

1. center the small secondary mirror.
use a small ruler that fits inside the tube.
the distance from tube to outer diameter of the base is about 48 mm.

2. align the secondary mirror.
loosen the three tiny screws on the secondary mirror base.
look through the focuser tube.
use a medium screwdriver to position the secondary mirror.
get a friend to tighten the tiny screws.
1/8 turn at a time.

3. align the focuser tube using shims.
repeat steps 2,3 as needed or until frustrated.

4. strap the scope into its cradle.
clamp it to a table.
place the artificial star field about 20' away.
attach camera with all 4 spacers.
fully extend the focuser.
remove cover.

5. run the zwo code.
exposure (e) about 10,000 us.
iso (1) about 2000.
show the collimation circles (k).
shift the cradle until a star is in view.
adjust focus so it's about 60% of the window height.

5. adjust the primary mirror so the shadow of the secondary mirror is centered.
there are three pairs of medium screws.
the right screw threads with the tube.
the left screw threads with the mirrror.
loosen one. tighten the other.
use your finger or screwdriver handle to determine which set to adjust.

6. to "lift" the mirror - loosen left, tighten right.
if the shadow is too far left then you need to lift the right.
usually you go in small increments.
but for the first time i do 1-2 complete turns to ensure this is the correct direction.
adjusting the mirror will move the star out of the field of view.
shift the cradle to the same or different star.
repeat with small steps. usually 1/4 turn.
repeat with a different pair of adjustment screws.
repeat until satisifed or frustrated.


camera oddities:

there are numerous pixels that appear to leak.
they accumulate color way faster than all other pixels.
even in the dark.
even with modest exposure times.
probably need to identify them and ignore them.
but then there are other pixels that leak a little.
so for long exposures they're too bright.
seems like we need to intentionally drift the image.
so we can identify the too-bright pixels.

i have the driver/library crash with long exposure times.
that was with the 1.26 library.
1.39 seems to be better.

the fastest i can get the camera to run at rull resolution is 4 fps.
it appears the camera is single buffered.
ie it can capture or unload.
it can't do both simultaneously.
so below 250 ms exposure time - fps is dominated by io transfer.
greater than 250 ms - fps is dominated by capture time.


notes for capture 2025-11-21
exposure: 600,000
iso: 3,000
gamma: 0.4


to do list:

- transfer input from window to menu.
queue keystrokes in window thread until return.
then append to command queue.
menu thread appends stdin to command queue.
menu thread executes commands in the queue.
add load script command to menu.

- account for leakage.
identify bad pixels.
subtract leakage from every pixel.
place cover.
find average dark for each pixel.
find average and std dev for all pixels.
mark any pixel more than N std dev from mean as bad.
remove cover.

- black menu handling
bc - clear black data
ba N - accumulate black data and find bad pixels for N frames.
bs X - subtract black average + X * std dev.
when there is black data...
zero image edge pixels for simplicity.
replace image bad pixels with average of neighbors.
subtract black[x,y] + X * std dev from every pixel.

- subtract sky background.
divide the image into 16 regions.
find median pixel color in each region.
fit to a 2d gradient.
subtract from image to make the background black.
